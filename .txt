-- GUI with Aimbot, Visuals, and Exploits
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Create a Test GUI to confirm rendering
local TestGui = Instance.new("ScreenGui")
TestGui.Name = "TestGui"
TestGui.ResetOnSpawn = false
TestGui.Enabled = true
TestGui.Parent = game:GetService("CoreGui")
print("TestGui parented to CoreGui:", TestGui.Parent)

local TestFrame = Instance.new("Frame")
TestFrame.Size = UDim2.new(0, 100, 0, 100)
TestFrame.Position = UDim2.new(0, 10, 0, 10)
TestFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
TestFrame.Parent = TestGui
print("TestFrame created at position:", TestFrame.Position)

-- Create Main GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "HackGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Enabled = true
ScreenGui.Parent = game:GetService("CoreGui")
print("ScreenGui parented to CoreGui:", ScreenGui.Parent)

local Frame = Instance.new("Frame")
Frame.Size = UDim2.new(0, 400, 0, 500)
Frame.Position = UDim2.new(0.5, -200, 0.5, -250)
Frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
Frame.Visible = true
Frame.Parent = ScreenGui
print("Frame position:", Frame.Position, "Frame size:", Frame.Size, "Frame visible:", Frame.Visible)

-- Make GUI Draggable with Left Click
local dragging
local dragInput
local dragStart
local startPos
local function update(input)
    local delta = input.Position - dragStart
    Frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

Frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = Frame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

Frame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Toggle GUI visibility with custom bind (default Q)
local bindKey = Enum.KeyCode.Q
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == bindKey then
        Frame.Visible = not Frame.Visible
        print("Toggled GUI visibility to:", Frame.Visible)
    end
end)

-- Tab System
local TabFrame = Instance.new("Frame")
TabFrame.Size = UDim2.new(1, 0, 0, 40)
TabFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
TabFrame.Parent = Frame

local function createTab(name, posX, contentFrame)
    local TabButton = Instance.new("TextButton")
    TabButton.Size = UDim2.new(0.25, 0, 1, 0)
    TabButton.Position = UDim2.new(posX, 0, 0, 0)
    TabButton.Text = name
    TabButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    TabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    TabButton.TextSize = 16
    TabButton.Parent = TabFrame
    
    TabButton.MouseButton1Click:Connect(function()
        for _, child in pairs(Frame:GetChildren()) do
            if child:IsA("Frame") and child ~= TabFrame then
                child.Visible = false
            end
        end
        contentFrame.Visible = true
        print("Switched to tab:", name)
    end)
end

-- Content Frames with Scrolling
local AimbotFrame = Instance.new("ScrollingFrame")
AimbotFrame.Size = UDim2.new(1, 0, 1, -40)
AimbotFrame.Position = UDim2.new(0, 0, 0, 40)
AimbotFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
AimbotFrame.Visible = true
AimbotFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
AimbotFrame.ScrollBarThickness = 8
AimbotFrame.Parent = Frame

local VisualsFrame = Instance.new("ScrollingFrame")
VisualsFrame.Size = UDim2.new(1, 0, 1, -40)
VisualsFrame.Position = UDim2.new(0, 0, 0, 40)
VisualsFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
VisualsFrame.Visible = false
VisualsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
VisualsFrame.ScrollBarThickness = 8
VisualsFrame.Parent = Frame

local ExploitsFrame = Instance.new("ScrollingFrame")
ExploitsFrame.Size = UDim2.new(1, 0, 1, -40)
ExploitsFrame.Position = UDim2.new(0, 0, 0, 40)
ExploitsFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
ExploitsFrame.Visible = false
ExploitsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
ExploitsFrame.ScrollBarThickness = 8
ExploitsFrame.Parent = Frame

local SettingsFrame = Instance.new("ScrollingFrame")
SettingsFrame.Size = UDim2.new(1, 0, 1, -40)
SettingsFrame.Position = UDim2.new(0, 0, 0, 40)
SettingsFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
SettingsFrame.Visible = false
SettingsFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
SettingsFrame.ScrollBarThickness = 8
SettingsFrame.Parent = Frame

createTab("Aimbot", 0, AimbotFrame)
createTab("Visuals", 0.25, VisualsFrame)
createTab("Exploits", 0.50, ExploitsFrame)
createTab("Settings", 0.75, SettingsFrame)

-- Helper function for toggle buttons
local function createToggleButton(parent, text, posY, callback)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0.9, 0, 0, 40)
    Button.Position = UDim2.new(0.05, 0, 0, posY)
    Button.Text = text .. ": OFF"
    Button.BackgroundColor3 = Color3.fromRGB(100, 0, 0)
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextSize = 14
    Button.Parent = parent
    local state = false
    
    Button.MouseButton1Click:Connect(function()
        state = not state
        Button.Text = text .. (state and ": ON" or ": OFF")
        Button.BackgroundColor3 = state and Color3.fromRGB(0, 100, 0) or Color3.fromRGB(100, 0, 0)
        callback(state)
        parent.CanvasSize = UDim2.new(0, 0, 0, posY + 50) -- Update canvas size
    end)
end

-- Helper function for text buttons (for settings)
local function createTextButton(parent, text, posY, callback)
    local Button = Instance.new("TextButton")
    Button.Size = UDim2.new(0.9, 0, 0, 40)
    Button.Position = UDim2.new(0.05, 0, 0, posY)
    Button.Text = text .. " (Current: " .. bindKey.Name .. ")"
    Button.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    Button.TextColor3 = Color3.fromRGB(255, 255, 255)
    Button.TextSize = 14
    Button.Parent = parent
    
    Button.MouseButton1Click:Connect(callback)
    parent.CanvasSize = UDim2.new(0, 0, 0, posY + 50) -- Update canvas size
end

-- Helper function for sliders with rounding on release
local function createSlider(parent, name, posY, minValue, maxValue, defaultValue, callback)
    local SliderFrame = Instance.new("Frame")
    SliderFrame.Size = UDim2.new(0.9, 0, 0, 40)
    SliderFrame.Position = UDim2.new(0.05, 0, 0, posY)
    SliderFrame.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    SliderFrame.Parent = parent

    local Label = Instance.new("TextLabel")
    Label.Size = UDim2.new(0.5, 0, 1, 0)
    Label.Position = UDim2.new(0, 0, 0, 0)
    Label.Text = name .. ": " .. defaultValue
    Label.TextColor3 = Color3.fromRGB(255, 255, 255)
    Label.BackgroundTransparency = 1
    Label.TextSize = 14
    Label.Parent = SliderFrame

    local SliderButton = Instance.new("TextButton")
    SliderButton.Size = UDim2.new(0.5, 0, 0.5, 0)
    SliderButton.Position = UDim2.new(0.5, 0, 0.25, 0)
    SliderButton.Text = ""
    SliderButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    SliderButton.Parent = SliderFrame

    local SliderFill = Instance.new("Frame")
    SliderFill.Size = UDim2.new((defaultValue - minValue) / (maxValue - minValue), 0, 1, 0)
    SliderFill.Position = UDim2.new(0, 0, 0, 0)
    SliderFill.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
    SliderFill.Parent = SliderButton

    local draggingSlider = false
    local currentValue = defaultValue
    SliderButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            draggingSlider = true
        end
    end)

    SliderButton.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            draggingSlider = false
            local roundedValue = math.round(currentValue)
            if maxValue == 2 then -- For TP position or tracer position slider
                roundedValue = math.clamp(roundedValue, 0, 2)
                if roundedValue == 0 then Label.Text = name .. ": Top"
                elseif roundedValue == 1 then Label.Text = name .. ": Behind"
                else Label.Text = name .. ": Front" end
            else
                Label.Text = name .. ": " .. roundedValue
            end
            SliderFill.Size = UDim2.new((roundedValue - minValue) / (maxValue - minValue), 0, 1, 0)
            callback(roundedValue)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if draggingSlider and input.UserInputType == Enum.UserInputType.MouseMovement then
            local mousePos = input.Position.X
            local buttonPos = SliderButton.AbsolutePosition.X
            local buttonSize = SliderButton.AbsoluteSize.X
            local relativePos = math.clamp((mousePos - buttonPos) / buttonSize, 0, 1)
            currentValue = minValue + (maxValue - minValue) * relativePos
            SliderFill.Size = UDim2.new(relativePos, 0, 1, 0)
            if maxValue == 2 then
                if math.round(currentValue) == 0 then Label.Text = name .. ": Top"
                elseif math.round(currentValue) == 1 then Label.Text = name .. ": Behind"
                else Label.Text = name .. ": Front" end
            else
                Label.Text = name .. ": " .. math.floor(currentValue + 0.5)
            end
        end
    end)
    parent.CanvasSize = UDim2.new(0, 0, 0, posY + 50) -- Update canvas size
end

-- Helper function for text boxes
local function createTextBox(parent, text, posY, defaultValue, callback)
    local TextBoxFrame = Instance.new("Frame")
    TextBoxFrame.Size = UDim2.new(0.9, 0, 0, 40)
    TextBoxFrame.Position = UDim2.new(0.05, 0, 0, posY)
    TextBoxFrame.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    TextBoxFrame.Parent = parent

    local Label = Instance.new("TextLabel")
    Label.Size = UDim2.new(0.3, 0, 1, 0)
    Label.Position = UDim2.new(0, 0, 0, 0)
    Label.Text = text
    Label.TextColor3 = Color3.fromRGB(255, 255, 255)
    Label.BackgroundTransparency = 1
    Label.TextSize = 14
    Label.Parent = TextBoxFrame

    local TextBox = Instance.new("TextBox")
    TextBox.Size = UDim2.new(0.6, 0, 0.8, 0)
    TextBox.Position = UDim2.new(0.35, 0, 0.1, 0)
    TextBox.Text = tostring(defaultValue)
    TextBox.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    TextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    TextBox.TextSize = 14
    TextBox.Parent = TextBoxFrame

    TextBox.FocusLost:Connect(function(enterPressed)
        if enterPressed then
            local num = tonumber(TextBox.Text) or defaultValue
            TextBox.Text = tostring(num)
            callback(num)
        end
    end)
    parent.CanvasSize = UDim2.new(0, 0, 0, posY + 50) -- Update canvas size
end

-- Aimbot Tab (Camera Lock-On with FOV)
local targetPlayer = nil
local aimbotActive = false
local deadCheckAimbot = false
local teamCheckAimbot = false
local aimbotFOVActive = false
local aimbotFOV = 100
local aimbotFOVCircle = Drawing.new("Circle")
aimbotFOVCircle.Color = Color3.fromRGB(255, 255, 255) -- White
aimbotFOVCircle.Thickness = 2
aimbotFOVCircle.Filled = false -- Hollow circle
aimbotFOVCircle.Transparency = 1
aimbotFOVCircle.Visible = false

local function getNearestPlayer()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return nil end
    local nearestDistance = math.huge
    local nearestPlayer = nil
    local mousePos = UserInputService:GetMouseLocation()
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= LocalPlayer and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = otherPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid and (not deadCheckAimbot or humanoid.Health > 0) then
                local isSameTeam = (LocalPlayer.Team and otherPlayer.Team and LocalPlayer.Team == otherPlayer.Team)
                if not teamCheckAimbot or not isSameTeam then
                    local screenPos = Camera:WorldToViewportPoint(otherPlayer.Character.HumanoidRootPart.Position)
                    local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                    if aimbotFOVActive and distance <= aimbotFOV and distance < nearestDistance then
                        nearestDistance = distance
                        nearestPlayer = otherPlayer
                    elseif not aimbotFOVActive and distance < nearestDistance then
                        nearestDistance = distance
                        nearestPlayer = otherPlayer
                    end
                end
            end
        end
    end
    return nearestPlayer
end

createToggleButton(AimbotFrame, "Aimbot (Right Click)", 10, function(state)
    aimbotActive = state
    if not state then
        RunService:UnbindFromRenderStep("LockOnPlayer")
        aimbotFOVCircle.Visible = false
    end
end)

createToggleButton(AimbotFrame, "Dead Check", 60, function(state)
    deadCheckAimbot = state
end)

createToggleButton(AimbotFrame, "Team Check", 110, function(state)
    teamCheckAimbot = state
end)

createToggleButton(AimbotFrame, "FOV Circle", 160, function(state)
    aimbotFOVActive = state
    aimbotFOVCircle.Visible = state and aimbotActive
end)

createSlider(AimbotFrame, "Aimbot FOV", 210, 1, 640, 100, function(value)
    aimbotFOV = value
    aimbotFOVCircle.Radius = value
end)

UserInputService.InputBegan:Connect(function(input)
    if aimbotActive and input.UserInputType == Enum.UserInputType.MouseButton2 then
        targetPlayer = getNearestPlayer()
        if targetPlayer then
            RunService:BindToRenderStep("LockOnPlayer", Enum.RenderPriority.Camera.Value + 1, function()
                if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    aimbotFOVCircle.Visible = aimbotFOVActive and aimbotActive
                    aimbotFOVCircle.Position = UserInputService:GetMouseLocation()
                    Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPlayer.Character.HumanoidRootPart.Position)
                else
                    RunService:UnbindFromRenderStep("LockOnPlayer")
                    aimbotFOVCircle.Visible = false
                end
            end)
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        RunService:UnbindFromRenderStep("LockOnPlayer")
        aimbotFOVCircle.Visible = false
    end
end)

-- Visuals Tab (ESP Features with FOV)
local espStates = {Box = false, Tracer = false, Name = false, Distance = false, Health = false, Skeleton = false}
local tracerPosition = 1 -- Default to Behind (0 = Top, 1 = Behind, 2 = Front)
local deadCheckVisuals = false
local teamCheckVisuals = false
local fovActive = false
local fovValue = 70 -- Default FOV (Roblox default is 70)
local espConnections = {}
local espObjects = {}

local function DrawESP(plr)
    if plr == LocalPlayer then return end
    
    local objects = {
        Box = Drawing.new("Quad"), Name = Drawing.new("Text"), Distance = Drawing.new("Text"),
        Health = Drawing.new("Line"), Tracer = Drawing.new("Line"), Skeleton = {}
    }
    objects.Box.Color = Color3.fromRGB(255, 255, 255)
    objects.Box.Thickness = 1
    objects.Box.Transparency = 1
    objects.Box.Visible = false
    objects.Name.Size = 18
    objects.Name.Color = Color3.fromRGB(255, 255, 255)
    objects.Name.Outline = true
    objects.Name.Visible = false
    objects.Distance.Size = 16
    objects.Distance.Color = Color3.fromRGB(255, 255, 255)
    objects.Distance.Outline = true
    objects.Distance.Visible = false
    objects.Health.Thickness = 3
    objects.Health.Visible = false
    objects.Tracer.Color = Color3.fromRGB(0, 255, 0)
    objects.Tracer.Thickness = 1
    objects.Tracer.Visible = false
    
    local bones = {
        {"Head", "UpperTorso"}, {"UpperTorso", "LowerTorso"}, {"LowerTorso", "LeftUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"}, {"LowerTorso", "RightUpperLeg"},
        {"RightUpperLeg", "RightLowerLeg"}, {"RightLowerLeg", "RightFoot"}, {"UpperTorso", "LeftUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"}, {"LeftLowerArm", "LeftHand"}, {"UpperTorso", "RightUpperArm"},
        {"RightUpperArm", "RightLowerArm"}, {"RightLowerArm", "RightHand"}
    }
    for _, pair in ipairs(bones) do
        local line = Drawing.new("Line")
        line.Color = Color3.fromRGB(255, 165, 0)
        line.Thickness = 2
        line.Visible = false
        objects.Skeleton[pair[1] .. pair[2]] = line
    end
    
    espObjects[plr] = objects
    
    local function Update()
        local connection
        connection = RunService.RenderStepped:Connect(function()
            if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then return end
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            if deadCheckVisuals and humanoid and humanoid.Health <= 0 then
                for _, obj in pairs(objects) do
                    if type(obj) == "table" then
                        for _, line in pairs(obj) do line.Visible = false end
                    else
                        obj.Visible = false
                    end
                end
                return
            end
            local isSameTeam = (LocalPlayer.Team and plr.Team and LocalPlayer.Team == plr.Team)
            if teamCheckVisuals and isSameTeam then
                for _, obj in pairs(objects) do
                    if type(obj) == "table" then
                        for _, line in pairs(obj) do line.Visible = false end
                    else
                        obj.Visible = false
                    end
                end
                return
            end
            
            local points = {
                TopLeft = Camera:WorldToViewportPoint((plr.Character.HumanoidRootPart.CFrame * CFrame.new(-2, 3, 0)).p),
                TopRight = Camera:WorldToViewportPoint((plr.Character.HumanoidRootPart.CFrame * CFrame.new(2, 3, 0)).p),
                BottomLeft = Camera:WorldToViewportPoint((plr.Character.HumanoidRootPart.CFrame * CFrame.new(-2, -3, 0)).p),
                BottomRight = Camera:WorldToViewportPoint((plr.Character.HumanoidRootPart.CFrame * CFrame.new(2, -3, 0)).p)
            }
            
            if espStates.Box then
                objects.Box.PointA = Vector2.new(points.TopRight.X, points.TopRight.Y)
                objects.Box.PointB = Vector2.new(points.TopLeft.X, points.TopLeft.Y)
                objects.Box.PointC = Vector2.new(points.BottomLeft.X, points.BottomLeft.Y)
                objects.Box.PointD = Vector2.new(points.BottomRight.X, points.BottomRight.Y)
                objects.Box.Visible = true
            else objects.Box.Visible = false end
            
            if espStates.Name then
                objects.Name.Position = Vector2.new(points.TopRight.X, points.TopRight.Y - 20)
                objects.Name.Text = plr.Name
                objects.Name.Visible = true
            else objects.Name.Visible = false end
            
            if espStates.Distance then
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (LocalPlayer.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                    objects.Distance.Position = Vector2.new(points.BottomRight.X, points.BottomRight.Y + 5)
                    objects.Distance.Text = math.floor(dist) .. "m"
                    objects.Distance.Visible = true
                end
            else objects.Distance.Visible = false end
            
            if espStates.Health then
                if humanoid then
                    local hp = humanoid.Health / humanoid.MaxHealth
                    objects.Health.From = Vector2.new(points.BottomRight.X + 5, points.BottomRight.Y)
                    objects.Health.To = Vector2.new(points.BottomRight.X + 5, points.TopRight.Y + ((points.BottomRight.Y - points.TopRight.Y) * (1 - hp)))
                    objects.Health.Color = Color3.fromRGB(0, 255, 0)
                    objects.Health.Visible = true
                end
            else objects.Health.Visible = false end
            
            if espStates.Tracer then
                local tracerY = Camera.ViewportSize.Y
                local tracerToX, tracerToY
                if tracerPosition == 0 then tracerY = Camera.ViewportSize.Y -- Top
                    tracerToX, tracerToY = points.BottomRight.X, points.BottomRight.Y
                elseif tracerPosition == 1 then tracerY = Camera.ViewportSize.Y / 2 -- Behind
                    if plr.Character and plr.Character:FindFirstChild("UpperTorso") then
                        print("Using UpperTorso for", plr.Name)
                        local chestPos = Camera:WorldToViewportPoint(plr.Character.UpperTorso.Position)
                        tracerToX, tracerToY = chestPos.X, chestPos.Y
                    elseif plr.Character and plr.Character:FindFirstChild("Torso") then
                        print("Using Torso for", plr.Name)
                        local chestPos = Camera:WorldToViewportPoint(plr.Character.Torso.Position)
                        tracerToX, tracerToY = chestPos.X, chestPos.Y
                    else
                        print("Falling back to BottomRight for", plr.Name)
                        tracerToX, tracerToY = points.BottomRight.X, points.BottomRight.Y
                    end
                elseif tracerPosition == 2 then tracerY = 0 -- Front
                    tracerToX, tracerToY = points.BottomRight.X, points.BottomRight.Y
                end
                objects.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, tracerY)
                objects.Tracer.To = Vector2.new(tracerToX, tracerToY)
                objects.Tracer.Visible = true
            else objects.Tracer.Visible = false end
            
            if espStates.Skeleton then
                for _, pair in ipairs(bones) do
                    local p1, p2 = plr.Character:FindFirstChild(pair[1]), plr.Character:FindFirstChild(pair[2])
                    if p1 and p2 then
                        local sp1, v1 = Camera:WorldToViewportPoint(p1.Position)
                        local sp2, v2 = Camera:WorldToViewportPoint(p2.Position)
                        if v1 and v2 then
                            objects.Skeleton[pair[1] .. pair[2]].From = Vector2.new(sp1.X, sp1.Y)
                            objects.Skeleton[pair[1] .. pair[2]].To = Vector2.new(sp2.X, sp2.Y)
                            objects.Skeleton[pair[1] .. pair[2]].Visible = true
                        else objects.Skeleton[pair[1] .. pair[2]].Visible = false end
                    end
                end
            else
                for _, line in pairs(objects.Skeleton) do line.Visible = false end
            end
        end)
        espConnections[plr] = connection
    end
    Update()
end

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        DrawESP(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    wait(1)
    if player ~= LocalPlayer then
        DrawESP(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if espObjects[player] then
        for _, obj in pairs(espObjects[player]) do
            if type(obj) == "table" then
                for _, line in pairs(obj) do
                    line:Remove()
                end
            else
                obj:Remove()
            end
        end
        espObjects[player] = nil
    end
    if espConnections[player] then
        espConnections[player]:Disconnect()
        espConnections[player] = nil
    end
end)

createToggleButton(VisualsFrame, "Box ESP", 10, function(state) espStates.Box = state end)
createToggleButton(VisualsFrame, "Tracers", 60, function(state) espStates.Tracer = state end)
createSlider(VisualsFrame, "Tracer Position", 110, 0, 2, 1, function(value)
    tracerPosition = value
    print("Tracer position set to:", tracerPosition)
end)
createToggleButton(VisualsFrame, "Name Tags", 160, function(state) espStates.Name = state end)
createToggleButton(VisualsFrame, "Distance", 210, function(state) espStates.Distance = state end)
createToggleButton(VisualsFrame, "Health Bar", 260, function(state) espStates.Health = state end)
createToggleButton(VisualsFrame, "Skeleton", 310, function(state) espStates.Skeleton = state end)
createToggleButton(VisualsFrame, "Dead Check", 360, function(state)
    deadCheckVisuals = state
end)
createToggleButton(VisualsFrame, "Team Check", 410, function(state)
    teamCheckVisuals = state
end)
createToggleButton(VisualsFrame, "FOV Toggle", 460, function(state)
    fovActive = state
    if fovActive then
        Camera.FieldOfView = fovValue
    else
        Camera.FieldOfView = 70 -- Reset to default
    end
end)
createSlider(VisualsFrame, "FOV", 510, 1, 200, 70, function(value)
    fovValue = value
    if fovActive then
        Camera.FieldOfView = fovValue
    end
end)

-- Exploits Tab (Admin Fly, No Clip, Fly Speed Slider, Spinbot, Loop TP, Save Last Position)
local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")
local flying = false
local speed = 75
local controlSpeed = 10000
local noClipActive = false
local noClipConnection = nil
local spinbotActive = false
local spinSpeed = 15 -- Default spin speed in degrees
local loopTPActive = false
local tpDistance = 10 -- Default teleport distance in studs
local tpPosition = 1 -- Default to Behind (0 = Top, 1 = Behind, 2 = Front)
local lastPosition = nil
local saveLastPosition = false
local deadCheckExploits = false
local teamCheckExploits = false

-- Admin Fly with Respawn Fix and Speed Slider
local function setupFly()
    if flying and rootPart and humanoid then
        if saveLastPosition and not lastPosition then
            lastPosition = rootPart.Position
        end
        humanoid.PlatformStand = true
        local bv = Instance.new("BodyVelocity")
        bv.Velocity = Vector3.new(0, 0, 0)
        bv.MaxForce = Vector3.new(controlSpeed, controlSpeed, controlSpeed)
        bv.Parent = rootPart
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(controlSpeed, controlSpeed, controlSpeed)
        bg.P = 5000
        bg.D = 500
        bg.CFrame = rootPart.CFrame
        bg.Parent = rootPart
        
        spawn(function()
            while flying and rootPart and humanoid do
                local cam = workspace.CurrentCamera
                local move = Vector3.new(0, 0, 0)
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + Vector3.new(0, 0, -1) end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move + Vector3.new(0, 0, 1) end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move + Vector3.new(-1, 0, 0) end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + Vector3.new(1, 0, 0) end
                if UserInputService:IsKeyDown(Enum.KeyCode.Space) then move = move + Vector3.new(0, 1, 0) end
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then move = move + Vector3.new(0, -1, 0) end
                
                if move.Magnitude > 0 then
                    move = move.Unit * speed
                    bv.Velocity = cam.CFrame:VectorToWorldSpace(move)
                    bg.CFrame = cam.CFrame
                else
                    bv.Velocity = Vector3.new(0, 0, 0)
                end
                wait()
            end
        end)
    end
end

local function toggleFly(state)
    flying = state
    if flying then
        setupFly()
    else
        humanoid.PlatformStand = false
        if rootPart:FindFirstChild("BodyVelocity") then rootPart.BodyVelocity:Destroy() end
        if rootPart:FindFirstChild("BodyGyro") then rootPart.BodyGyro:Destroy() end
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        if saveLastPosition and lastPosition then
            rootPart.CFrame = CFrame.new(lastPosition)
            lastPosition = nil
        end
    end
end

-- Spinbot with Adjustable Speed
local spinbotConnection = nil
local function toggleSpinbot(state)
    spinbotActive = state
    if spinbotActive and rootPart then
        spinbotConnection = RunService.RenderStepped:Connect(function()
            if rootPart then
                rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
            end
        end)
    elseif spinbotConnection then
        spinbotConnection:Disconnect()
        spinbotConnection = nil
    end
end

-- Loop TP to Player (Using Provided Script)
local tpConnection = nil
local function getNearestEnemy()
    local nearestDistance = math.huge
    local nearestEnemy = nil
    local myRoot = character and character:FindFirstChild("HumanoidRootPart")
    local myTeam = LocalPlayer.Team

    if not myRoot then
        print("No root part found for local player")
        return nil
    end

    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= LocalPlayer and 
           otherPlayer.Team ~= myTeam and -- Ignore teammates
           otherPlayer.Character and 
           otherPlayer.Character:FindFirstChild("HumanoidRootPart") and 
           otherPlayer.Character:FindFirstChildOfClass("Humanoid") and 
           otherPlayer.Character:FindFirstChildOfClass("Humanoid").Health > 0 -- Ignore dead players
        then
            local otherRoot = otherPlayer.Character.HumanoidRootPart
            local distance = (myRoot.Position - otherRoot.Position).Magnitude
            print("Checking player:", otherPlayer.Name, "Distance:", distance)

            if distance < nearestDistance then
                nearestDistance = distance
                nearestEnemy = otherPlayer
            end
        end
    end

    if nearestEnemy then
        print("Nearest enemy found:", nearestEnemy.Name)
    else
        print("No nearest enemy found")
    end
    return nearestEnemy
end

local function aimlock()
    if not character or not Camera or not loopTPActive or not rootPart then return end

    local target = getNearestEnemy()
    if target and target.Character then
        local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            local lookVector = targetRoot.CFrame.LookVector
            local offset = tpDistance
            local tpPos = targetRoot.Position
            if tpPosition == 0 then -- Top
                tpPos = tpPos + Vector3.new(0, offset, 0)
            elseif tpPosition == 1 then -- Behind
                tpPos = tpPos - lookVector * offset
            elseif tpPosition == 2 then -- Front
                tpPos = tpPos + lookVector * offset
            end
            rootPart.CFrame = CFrame.new(tpPos)
            print("Teleported to:", tpPos)
        else
            print("No target root found for:", target.Name)
        end
    end
end

local function toggleLoopTP(state)
    loopTPActive = state
    if loopTPActive and rootPart then
        tpConnection = RunService.RenderStepped:Connect(aimlock)
        print("Loop TP activated")
    elseif tpConnection then
        tpConnection:Disconnect()
        tpConnection = nil
        print("Loop TP deactivated")
    end
end

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    rootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    if flying then
        setupFly()
    end
    if noClipActive then
        toggleNoClip(true)
    end
    if spinbotActive then
        toggleSpinbot(true)
    end
    if loopTPActive then
        toggleLoopTP(true)
    end
end)

-- No Clip Feature with Proper Toggle Off
local function toggleNoClip(state)
    noClipActive = state
    if noClipActive then
        local function noClip()
            if character and rootPart then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end
        noClipConnection = RunService.Stepped:Connect(noClip)
    else
        if noClipConnection then
            noClipConnection:Disconnect()
            noClipConnection = nil
        end
        if character then
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end

createToggleButton(ExploitsFrame, "Admin Fly", 10, toggleFly)
createSlider(ExploitsFrame, "Fly Speed", 60, 10, 200, 75, function(value)
    speed = value
    print("Fly speed set to:", speed)
end)
createToggleButton(ExploitsFrame, "No Clip", 110, toggleNoClip)
createToggleButton(ExploitsFrame, "Spinbot", 160, toggleSpinbot)
createTextBox(ExploitsFrame, "Spin Speed", 210, 15, function(value)
    spinSpeed = value
    print("Spin speed set to:", spinSpeed)
end)
createToggleButton(ExploitsFrame, "Loop TP to Player", 260, toggleLoopTP)
createTextBox(ExploitsFrame, "TP Distance", 310, 10, function(value)
    tpDistance = value
    print("TP distance set to:", tpDistance)
end)
createSlider(ExploitsFrame, "TP Position", 360, 0, 2, 1, function(value)
    tpPosition = value
    print("TP position set to:", tpPosition)
end)
createToggleButton(ExploitsFrame, "Save Last Position", 410, function(state)
    saveLastPosition = state
end)
createToggleButton(ExploitsFrame, "Dead Check", 460, function(state)
    deadCheckExploits = state
end)
createToggleButton(ExploitsFrame, "Team Check", 510, function(state)
    teamCheckExploits = state
end)

-- Settings Tab (Change Bind with Improved Behavior)
local bindChangeActive = false
createTextButton(SettingsFrame, "Change GUI Bind", 10, function()
    if not bindChangeActive then
        bindChangeActive = true
        local button = SettingsFrame:FindFirstChild("Change GUI Bind")
        if button then
            button.Text = "Change GUI Bind (Press a key)"
        end
        local bindChangeConnection
        bindChangeConnection = UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Keyboard and bindChangeActive then
                bindKey = input.KeyCode
                if button then
                    button.Text = "Change GUI Bind (Current: " .. bindKey.Name .. ")"
                end
                print("New GUI bind set to:", bindKey.Name)
                bindChangeActive = false
                bindChangeConnection:Disconnect()
            end
        end)
    end
end)

print("GUI Loaded! Use the tabs to toggle features. Press Q to toggle GUI visibility (or custom bind). Drag with left click.")
