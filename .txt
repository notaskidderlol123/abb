local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Camera = workspace.CurrentCamera
local PlayersService = game:GetService("Players")

-- Safely get LocalPlayer with a wait loop
local LocalPlayer
while not PlayersService.LocalPlayer do
    wait(0.1)
end
LocalPlayer = PlayersService.LocalPlayer

-- Function to get character safely
local function getCharacter()
    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

-- GUI Setup (unchanged)
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "CustomExecutor"
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ResetOnSpawn = false

local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 400, 0, 300)
MainFrame.Position = UDim2.new(0.5, -200, 0.5, -150)
MainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
MainFrame.BackgroundTransparency = 1
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

local TabFrame = Instance.new("Frame")
TabFrame.Size = UDim2.new(1, 0, 0, 30)
TabFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
TabFrame.BackgroundTransparency = 1
TabFrame.BorderSizePixel = 0
TabFrame.Parent = MainFrame

local ContentFrame = Instance.new("Frame")
ContentFrame.Size = UDim2.new(1, 0, 1, -30)
ContentFrame.Position = UDim2.new(0, 0, 0, 30)
ContentFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
ContentFrame.BackgroundTransparency = 1
ContentFrame.BorderSizePixel = 0
ContentFrame.Parent = MainFrame

local tabs = {"Aimbot", "Visuals", "Exploits"}
local currentTab = nil
local tabContents = {}

for i, tabName in ipairs(tabs) do
    local TabButton = Instance.new("TextButton")
    TabButton.Size = UDim2.new(0, 133, 1, 0)
    TabButton.Position = UDim2.new(0, (i-1) * 133, 0, 0)
    TabButton.Text = tabName
    TabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    TabButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    TabButton.BackgroundTransparency = 1
    TabButton.TextTransparency = 1
    TabButton.BorderSizePixel = 0
    TabButton.Font = Enum.Font.SourceSans
    TabButton.TextSize = 18
    TabButton.Parent = TabFrame

    local Content = Instance.new("Frame")
    Content.Size = UDim2.new(1, 0, 1, 0)
    Content.BackgroundTransparency = 1
    Content.Visible = false
    Content.Parent = ContentFrame
    tabContents[tabName] = Content

    TabButton.MouseButton1Click:Connect(function()
        if currentTab ~= tabName then
            currentTab = tabName
            for _, content in pairs(tabContents) do
                content.Visible = false
            end
            tabContents[tabName].Visible = true
            for _, button in pairs(TabFrame:GetChildren()) do
                if button:IsA("TextButton") then
                    button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                end
            end
            TabButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
        end
    end)
end

-- Aimbot Tab (Updated with Document's Logic, No Smoothness)
local aimbotEnabled = false
local aimbotFovSize = 50
local aimbotAimPart = "Head"
local aimbotKeybind = Enum.UserInputType.MouseButton2
local aimbotPredictionEnabled = false
local aimbotPredictionStrengthX = 0
local aimbotPredictionStrengthY = 0
local aimbotStickyAimEnabled = false
local lockedTarget = nil

local AimbotToggle = Instance.new("TextButton")
AimbotToggle.Size = UDim2.new(0, 100, 0, 30)
AimbotToggle.Position = UDim2.new(0, 10, 0, 10)
AimbotToggle.Text = "Aimbot: OFF"
AimbotToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
AimbotToggle.BackgroundTransparency = 1
AimbotToggle.TextTransparency = 1
AimbotToggle.TextColor3 = Color3.fromRGB(255, 0, 0)
AimbotToggle.Font = Enum.Font.SourceSans
AimbotToggle.TextSize = 16
AimbotToggle.Parent = tabContents["Aimbot"]

local function aimbot()
    if not aimbotEnabled or not aimbotKeybind then
        return
    end

    if aimbotKeybind == Enum.UserInputType.MouseButton2 then
        if not UserInputService:IsMouseButtonPressed(aimbotKeybind) then
            lockedTarget = nil
            return
        end
    else
        if not UserInputService:IsKeyDown(aimbotKeybind) then
            lockedTarget = nil
            return
        end
    end

    local mouse = LocalPlayer:GetMouse()
    if lockedTarget and aimbotStickyAimEnabled then
        if lockedTarget.Character and lockedTarget.Character:FindFirstChild(aimbotAimPart) then
            local part = lockedTarget.Character[aimbotAimPart]
            local predictedPosition = part.Position
            if aimbotPredictionEnabled then
                local velocity = lockedTarget.Character.HumanoidRootPart.Velocity
                predictedPosition = part.Position + Vector3.new(
                    velocity.X * aimbotPredictionStrengthX * 0.1,
                    velocity.Y * aimbotPredictionStrengthY * 0.1,
                    0
                )
            end
            local screenPos = Camera:WorldToViewportPoint(predictedPosition)
            local target = Vector2.new(screenPos.X, screenPos.Y)
            local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local move = target - screenCenter
            mousemoverel(move.X, move.Y)
            return
        else
            lockedTarget = nil
        end
    end

    local closestPlayer = nil
    local closestDistance = aimbotFovSize

    for _, player in pairs(PlayersService:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(aimbotAimPart) then
            local part = player.Character[aimbotAimPart]
            local predictedPosition = part.Position
            if aimbotPredictionEnabled then
                local velocity = player.Character.HumanoidRootPart.Velocity
                predictedPosition = part.Position + Vector3.new(
                    velocity.X * aimbotPredictionStrengthX * 0.1,
                    velocity.Y * aimbotPredictionStrengthY * 0.1,
                    0
                )
            end
            local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPosition)
            if onScreen then
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end

    if closestPlayer then
        lockedTarget = closestPlayer
        local part = closestPlayer.Character[aimbotAimPart]
        local predictedPosition = part.Position
        if aimbotPredictionEnabled then
            local velocity = closestPlayer.Character.HumanoidRootPart.Velocity
            predictedPosition = part.Position + Vector3.new(
                velocity.X * aimbotPredictionStrengthX * 0.1,
                velocity.Y * aimbotPredictionStrengthY * 0.1,
                0
            )
        end
        local screenPos = Camera:WorldToViewportPoint(predictedPosition)
        local target = Vector2.new(screenPos.X, screenPos.Y)
        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        local move = target - screenCenter
        mousemoverel(move.X, move.Y)
    end
end

AimbotToggle.MouseButton1Click:Connect(function()
    aimbotEnabled = not aimbotEnabled
    AimbotToggle.Text = "Aimbot: " .. (aimbotEnabled and "ON" or "OFF")
    AimbotToggle.TextColor3 = aimbotEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
end)

RunService.RenderStepped:Connect(aimbot)

local FovCircle = Drawing.new("Circle")
FovCircle.Color = Color3.fromRGB(255, 255, 255)
FovCircle.Thickness = 1
FovCircle.Transparency = 1
FovCircle.Filled = false

local ShowFovToggle = Instance.new("TextButton")
ShowFovToggle.Size = UDim2.new(0, 100, 0, 30)
ShowFovToggle.Position = UDim2.new(0, 10, 0, 50)
ShowFovToggle.Text = "Show FOV: OFF"
ShowFovToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
ShowFovToggle.BackgroundTransparency = 1
ShowFovToggle.TextTransparency = 1
ShowFovToggle.TextColor3 = Color3.fromRGB(255, 0, 0)
ShowFovToggle.Font = Enum.Font.SourceSans
ShowFovToggle.TextSize = 16
ShowFovToggle.Parent = tabContents["Aimbot"]

local showFov = false
ShowFovToggle.MouseButton1Click:Connect(function()
    showFov = not showFov
    ShowFovToggle.Text = "Show FOV: " .. (showFov and "ON" or "OFF")
    ShowFovToggle.TextColor3 = showFov and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
end)

local function updateFovCircle()
    if showFov then
        local mousePos = UserInputService:GetMouseLocation()
        FovCircle.Radius = aimbotFovSize
        FovCircle.Position = Vector2.new(mousePos.X, mousePos.Y)
        FovCircle.Visible = true
    else
        FovCircle.Visible = false
    end
end

RunService.RenderStepped:Connect(updateFovCircle)

local PredictionToggle = Instance.new("TextButton")
PredictionToggle.Size = UDim2.new(0, 100, 0, 30)
PredictionToggle.Position = UDim2.new(0, 10, 0, 90)
PredictionToggle.Text = "Prediction: OFF"
PredictionToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
PredictionToggle.BackgroundTransparency = 1
PredictionToggle.TextTransparency = 1
PredictionToggle.TextColor3 = Color3.fromRGB(255, 0, 0)
PredictionToggle.Font = Enum.Font.SourceSans
PredictionToggle.TextSize = 16
PredictionToggle.Parent = tabContents["Aimbot"]

PredictionToggle.MouseButton1Click:Connect(function()
    aimbotPredictionEnabled = not aimbotPredictionEnabled
    PredictionToggle.Text = "Prediction: " .. (aimbotPredictionEnabled and "ON" or "OFF")
    PredictionToggle.TextColor3 = aimbotPredictionEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
end)

local StickyAimToggle = Instance.new("TextButton")
StickyAimToggle.Size = UDim2.new(0, 100, 0, 30)
StickyAimToggle.Position = UDim2.new(0, 10, 0, 130)
StickyAimToggle.Text = "Sticky Aim: OFF"
StickyAimToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
StickyAimToggle.BackgroundTransparency = 1
StickyAimToggle.TextTransparency = 1
StickyAimToggle.TextColor3 = Color3.fromRGB(255, 0, 0)
StickyAimToggle.Font = Enum.Font.SourceSans
StickyAimToggle.TextSize = 16
StickyAimToggle.Parent = tabContents["Aimbot"]

StickyAimToggle.MouseButton1Click:Connect(function()
    aimbotStickyAimEnabled = not aimbotStickyAimEnabled
    StickyAimToggle.Text = "Sticky Aim: " .. (aimbotStickyAimEnabled and "ON" or "OFF")
    StickyAimToggle.TextColor3 = aimbotStickyAimEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
end)

local FovSizeSlider = Instance.new("TextButton")
FovSizeSlider.Size = UDim2.new(0, 200, 0, 20)
FovSizeSlider.Position = UDim2.new(0, 10, 0, 170)
FovSizeSlider.Text = ""
FovSizeSlider.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
FovSizeSlider.BackgroundTransparency = 1
FovSizeSlider.Parent = tabContents["Aimbot"]

local FovSizeKnob = Instance.new("Frame")
FovSizeKnob.Size = UDim2.new(0, 10, 1, 0)
FovSizeKnob.Position = UDim2.new((aimbotFovSize / 100), 0, 0, 0)
FovSizeKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 252)
FovSizeKnob.BackgroundTransparency = 1
FovSizeKnob.Parent = FovSizeSlider

local draggingFovSlider = false
FovSizeSlider.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingFovSlider = true
    end
end)

FovSizeSlider.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingFovSlider = false
    end
end)

RunService.RenderStepped:Connect(function()
    if draggingFovSlider then
        local mouseX = UserInputService:GetMouseLocation().X
        local sliderPos = FovSizeSlider.AbsolutePosition.X
        local sliderWidth = FovSizeSlider.AbsoluteSize.X
        local newPos = math.clamp((mouseX - sliderPos) / sliderWidth, 0, 1)
        FovSizeKnob.Position = UDim2.new(newPos, 0, 0, 0)
        aimbotFovSize = math.floor(newPos * 100)
    end
end)

local AimPartDropdown = Instance.new("TextButton")
AimPartDropdown.Size = UDim2.new(0, 100, 0, 30)
AimPartDropdown.Position = UDim2.new(0, 10, 0, 200)
AimPartDropdown.Text = "Aim Part: Head"
AimPartDropdown.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
AimPartDropdown.BackgroundTransparency = 1
AimPartDropdown.TextTransparency = 1
AimPartDropdown.TextColor3 = Color3.fromRGB(255, 255, 255)
AimPartDropdown.Font = Enum.Font.SourceSans
AimPartDropdown.TextSize = 16
AimPartDropdown.Parent = tabContents["Aimbot"]

local aimPartIndex = 1
local aimParts = {"Head", "HumanoidRootPart"}
AimPartDropdown.MouseButton1Click:Connect(function()
    aimPartIndex = aimPartIndex % #aimParts + 1
    aimbotAimPart = aimParts[aimPartIndex]
    AimPartDropdown.Text = "Aim Part: " .. aimbotAimPart
end)

local PredictionStrengthXSlider = Instance.new("TextButton")
PredictionStrengthXSlider.Size = UDim2.new(0, 200, 0, 20)
PredictionStrengthXSlider.Position = UDim2.new(0, 10, 0, 240)
PredictionStrengthXSlider.Text = ""
PredictionStrengthXSlider.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
PredictionStrengthXSlider.BackgroundTransparency = 1
PredictionStrengthXSlider.Parent = tabContents["Aimbot"]

local PredictionStrengthXKnob = Instance.new("Frame")
PredictionStrengthXKnob.Size = UDim2.new(0, 10, 1, 0)
PredictionStrengthXKnob.Position = UDim2.new(aimbotPredictionStrengthX, 0, 0, 0)
PredictionStrengthXKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 252)
PredictionStrengthXKnob.BackgroundTransparency = 1
PredictionStrengthXKnob.Parent = PredictionStrengthXSlider

local draggingPredXSlider = false
PredictionStrengthXSlider.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingPredXSlider = true
    end
end)

PredictionStrengthXSlider.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingPredXSlider = false
    end
end)

RunService.RenderStepped:Connect(function()
    if draggingPredXSlider then
        local mouseX = UserInputService:GetMouseLocation().X
        local sliderPos = PredictionStrengthXSlider.AbsolutePosition.X
        local sliderWidth = PredictionStrengthXSlider.AbsoluteSize.X
        local newPos = math.clamp((mouseX - sliderPos) / sliderWidth, 0, 1)
        PredictionStrengthXKnob.Position = UDim2.new(newPos, 0, 0, 0)
        aimbotPredictionStrengthX = newPos
    end
end)

local PredictionStrengthYSlider = Instance.new("TextButton")
PredictionStrengthYSlider.Size = UDim2.new(0, 200, 0, 20)
PredictionStrengthYSlider.Position = UDim2.new(0, 10, 0, 270)
PredictionStrengthYSlider.Text = ""
PredictionStrengthYSlider.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
PredictionStrengthYSlider.BackgroundTransparency = 1
PredictionStrengthYSlider.Parent = tabContents["Aimbot"]

local PredictionStrengthYKnob = Instance.new("Frame")
PredictionStrengthYKnob.Size = UDim2.new(0, 10, 1, 0)
PredictionStrengthYKnob.Position = UDim2.new(aimbotPredictionStrengthY, 0, 0, 0)
PredictionStrengthYKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 252)
PredictionStrengthYKnob.BackgroundTransparency = 1
PredictionStrengthYKnob.Parent = PredictionStrengthYSlider

local draggingPredYSlider = false
PredictionStrengthYSlider.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingPredYSlider = true
    end
end)

PredictionStrengthYSlider.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingPredYSlider = false
    end
end)

RunService.RenderStepped:Connect(function()
    if draggingPredYSlider then
        local mouseX = UserInputService:GetMouseLocation().X
        local sliderPos = PredictionStrengthYSlider.AbsolutePosition.X
        local sliderWidth = PredictionStrengthYSlider.AbsoluteSize.X
        local newPos = math.clamp((mouseX - sliderPos) / sliderWidth, 0, 1)
        PredictionStrengthYKnob.Position = UDim2.new(newPos, 0, 0, 0)
        aimbotPredictionStrengthY = newPos
    end
end)

-- Visuals Tab (Unchanged)
local espToggles = {
    Box = false,
    Name = false,
    Distance = false,
    HealthBar = false,
    Tracer = true,
    Skeleton = false,
    Box3D = false
}

local espPlayers = {}
local function DrawESP(plr)
    local drawings = {
        Box = Drawing.new("Quad"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text"),
        HealthBarGreen = Drawing.new("Line"),
        HealthBarRed = Drawing.new("Line"),
        HealthLabel = Drawing.new("Text"),
        Tracer = Drawing.new("Line"),
        Skeleton = {},
        Box3D = {}
    }
    
    drawings.Box.Color = Color3.fromRGB(255, 255, 255)
    drawings.Box.Thickness = 1
    drawings.Box.Transparency = 1
    drawings.Box.Visible = false

    drawings.Name.Size = 18
    drawings.Name.Color = Color3.fromRGB(255, 255, 255)
    drawings.Name.Outline = true
    drawings.Name.Visible = false

    drawings.Distance.Size = 16
    drawings.Distance.Color = Color3.fromRGB(255, 255, 255)
    drawings.Distance.Outline = true
    drawings.Distance.Visible = false

    drawings.HealthBarGreen.Thickness = 10
    drawings.HealthBarGreen.Color = Color3.fromRGB(0, 255, 0)
    drawings.HealthBarGreen.Visible = false

    drawings.HealthBarRed.Thickness = 10
    drawings.HealthBarRed.Color = Color3.fromRGB(255, 0, 0)
    drawings.HealthBarRed.Visible = false

    drawings.HealthLabel.Size = 14
    drawings.HealthLabel.Color = Color3.fromRGB(255, 255, 255)
    drawings.HealthLabel.Outline = true
    drawings.HealthLabel.Visible = false

    drawings.Tracer.Color = Color3.fromRGB(0, 255, 0)
    drawings.Tracer.Thickness = 1
    drawings.Tracer.Visible = false

    local bones = {
        {"Head", "UpperTorso"}, {"UpperTorso", "LowerTorso"},
        {"LowerTorso", "LeftUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"},
        {"LowerTorso", "RightUpperLeg"}, {"RightUpperLeg", "RightLowerLeg"}, {"RightLowerLeg", "RightFoot"},
        {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"}, {"LeftLowerArm", "LeftHand"},
        {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"}, {"RightUpperArm", "RightHand"}
    }
    for _, pair in ipairs(bones) do
        local line = Drawing.new("Line")
        line.Color = Color3.fromRGB(255, 165, 0)
        line.Thickness = 2
        line.Visible = false
        drawings.Skeleton[pair[1] .. pair[2]] = line
    end

    local box3DIndices = {
        {1, 2}, {2, 3}, {3, 4}, {4, 1},
        {5, 6}, {6, 7}, {7, 8}, {8, 5},
        {1, 5}, {2, 6}, {3, 7}, {4, 8}
    }
    for i, edge in ipairs(box3DIndices) do
        local line = Drawing.new("Line")
        line.Color = Color3.fromRGB(0, 255, 255)
        line.Thickness = 1
        line.Visible = false
        drawings.Box3D[i] = line
    end

    local function Update()
        local connection
        local character = getCharacter()
        local rootPart = character:WaitForChild("HumanoidRootPart")
        connection = RunService.RenderStepped:Connect(function()
            if plr.Character and plr.Character.PrimaryPart and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character:FindFirstChildOfClass("Humanoid").Health > 0 then
                local pos, vis = Camera:WorldToViewportPoint(plr.Character.PrimaryPart.Position)
                if vis then
                    local TopLeft = Camera:WorldToViewportPoint((plr.Character.PrimaryPart.CFrame * CFrame.new(-2, 3, 0)).p)
                    local TopRight = Camera:WorldToViewportPoint((plr.Character.PrimaryPart.CFrame * CFrame.new(2, 3, 0)).p)
                    local BottomLeft = Camera:WorldToViewportPoint((plr.Character.PrimaryPart.CFrame * CFrame.new(-2, -3, 0)).p)
                    local BottomRight = Camera:WorldToViewportPoint((plr.Character.PrimaryPart.CFrame * CFrame.new(2, -3, 0)).p)
                    local headPart = plr.Character:FindFirstChild("Head") or plr.Character.PrimaryPart
                    local headPos, headVis
                    if headPart then
                        headPos, headVis = Camera:WorldToViewportPoint((headPart.CFrame * CFrame.new(0, 0.5, 0)).p)
                    else
                        headPos, headVis = Camera:WorldToViewportPoint(plr.Character.PrimaryPart.Position), true
                    end

                    if espToggles.Box then
                        drawings.Box.PointA = Vector2.new(TopRight.X, TopRight.Y)
                        drawings.Box.PointB = Vector2.new(TopLeft.X, TopLeft.Y)
                        drawings.Box.PointC = Vector2.new(BottomLeft.X, BottomLeft.Y)
                        drawings.Box.PointD = Vector2.new(BottomRight.X, BottomRight.Y)
                        drawings.Box.Visible = true
                    else
                        drawings.Box.Visible = false
                    end

                    if espToggles.Name and headVis then
                        drawings.Name.Position = Vector2.new(TopRight.X, TopRight.Y - 20)
                        drawings.Name.Text = plr.Name
                        drawings.Name.Visible = true
                    else
                        drawings.Name.Visible = false
                    end

                    if espToggles.Distance then
                        local playerDistance = (rootPart.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                        drawings.Distance.Position = Vector2.new(BottomRight.X, BottomRight.Y + 5)
                        drawings.Distance.Text = tostring(math.floor(playerDistance)) .. "m"
                        drawings.Distance.Visible = true
                    else
                        drawings.Distance.Visible = false
                    end

                    if espToggles.HealthBar and headVis then
                        local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            local healthPercent = humanoid.Health / humanoid.MaxHealth
                            local barHeight = 50
                            local barWidth = 10
                            local barX = TopLeft.X - 20
                            local barY = TopLeft.Y

                            drawings.HealthBarGreen.From = Vector2.new(barX, barY + (barHeight * (1 - healthPercent)))
                            drawings.HealthBarGreen.To = Vector2.new(barX + barWidth, barY + (barHeight * (1 - healthPercent)))
                            drawings.HealthBarGreen.Visible = true

                            drawings.HealthBarRed.From = Vector2.new(barX, barY)
                            drawings.HealthBarRed.To = Vector2.new(barX + barWidth, barY + (barHeight * (1 - healthPercent)))
                            drawings.HealthBarRed.Visible = true

                            drawings.HealthLabel.Position = Vector2.new(barX - 30, barY + (barHeight / 2) - 10)
                            drawings.HealthLabel.Text = "Health: " .. math.floor(humanoid.Health) .. "%"
                            drawings.HealthLabel.Visible = true
                        end
                    else
                        drawings.HealthBarGreen.Visible = false
                        drawings.HealthBarRed.Visible = false
                        drawings.HealthLabel.Visible = false
                    end

                    if espToggles.Tracer then
                        local chest = plr.Character:FindFirstChild("UpperTorso") or plr.Character:FindFirstChild("Torso")
                        if chest then
                            local chestPos, chestVis = Camera:WorldToViewportPoint(chest.Position)
                            if chestVis then
                                drawings.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                                drawings.Tracer.To = Vector2.new(chestPos.X, chestPos.Y)
                                drawings.Tracer.Visible = true
                            else
                                drawings.Tracer.Visible = false
                            end
                        else
                            drawings.Tracer.Visible = false
                        end
                    else
                        drawings.Tracer.Visible = false
                    end

                    if espToggles.Skeleton then
                        for _, pair in ipairs(bones) do
                            local p1 = plr.Character:FindFirstChild(pair[1])
                            local p2 = plr.Character:FindFirstChild(pair[2])
                            if p1 and p2 then
                                local screenP1, vis1 = Camera:WorldToViewportPoint(p1.Position)
                                local screenP2, vis2 = Camera:WorldToViewportPoint(p2.Position)
                                if vis1 and vis2 then
                                    local boneLine = drawings.Skeleton[pair[1] .. pair[2]]
                                    boneLine.From = Vector2.new(screenP1.X, screenP1.Y)
                                    boneLine.To = Vector2.new(screenP2.X, screenP2.Y)
                                    boneLine.Visible = true
                                else
                                    drawings.Skeleton[pair[1] .. pair[2]].Visible = false
                                end
                            end
                        end
                    else
                        for _, line in pairs(drawings.Skeleton) do
                            line.Visible = false
                        end
                    end

                    if espToggles.Box3D then
                        local size = plr.Character:GetExtentsSize() * 1.1
                        local cf = plr.Character.PrimaryPart.CFrame
                        local corners = {
                            cf * CFrame.new(-size.X/2,  size.Y/2, -size.Z/2),
                            cf * CFrame.new( size.X/2,  size.Y/2, -size.Z/2),
                            cf * CFrame.new( size.X/2, -size.Y/2, -size.Z/2),
                            cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2),
                            cf * CFrame.new(-size.X/2,  size.Y/2,  size.Z/2),
                            cf * CFrame.new( size.X/2,  size.Y/2,  size.Z/2),
                            cf * CFrame.new( size.X/2, -size.Y/2,  size.Z/2),
                            cf * CFrame.new(-size.X/2, -size.Y/2,  size.Z/2)
                        }
                        local screenCorners = {}
                        local allVisible = true
                        for i, corner in ipairs(corners) do
                            local screenPos, vis = Camera:WorldToViewportPoint(corner.p)
                            screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
                            if not vis then allVisible = false end
                        end
                        if allVisible then
                            for i, edge in ipairs(box3DIndices) do
                                local line = drawings.Box3D[i]
                                line.From = screenCorners[edge[1]]
                                line.To = screenCorners[edge[2]]
                                line.Visible = true
                            end
                        else
                            for _, line in ipairs(drawings.Box3D) do
                                line.Visible = false
                            end
                        end
                    else
                        for _, line in ipairs(drawings.Box3D) do
                            line.Visible = false
                        end
                    end
                else
                    for _, drawing in pairs(drawings) do
                        if type(drawing) == "table" then
                            for _, line in pairs(drawing) do line.Visible = false end
                        else
                            drawing.Visible = false
                        end
                    end
                end
            else
                for _, drawing in pairs(drawings) do
                    if type(drawing) == "table" then
                        for _, line in pairs(drawing) do line.Visible = false end
                    else
                        drawing.Visible = false
                    end
                end
                if not PlayersService:FindFirstChild(plr.Name) then
                    connection:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Update)()
    espPlayers[plr] = drawings
end

for _, player in pairs(PlayersService:GetPlayers()) do
    if player ~= LocalPlayer then
        local success, err = pcall(function()
            DrawESP(player)
        end)
        if not success then
            warn("Failed to apply ESP to player " .. player.Name .. ": " .. err)
        end
    end
end

PlayersService.PlayerAdded:Connect(function(player)
    wait(1)
    if player ~= LocalPlayer then
        local success, err = pcall(function()
            DrawESP(player)
        end)
        if not success then
            warn("Failed to apply ESP to player " .. player.Name .. ": " .. err)
        end
    end
end)

local yOffset = 10
for feature, enabled in pairs(espToggles) do
    local Toggle = Instance.new("TextButton")
    Toggle.Size = UDim2.new(0, 100, 0, 30)
    Toggle.Position = UDim2.new(0, 10, 0, yOffset)
    Toggle.Text = feature .. ": " .. (enabled and "ON" or "OFF")
    Toggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    Toggle.BackgroundTransparency = 1
    Toggle.TextTransparency = 1
    Toggle.TextColor3 = enabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    Toggle.Font = Enum.Font.SourceSans
    Toggle.TextSize = 16
    Toggle.Parent = tabContents["Visuals"]

    Toggle.MouseButton1Click:Connect(function()
        espToggles[feature] = not espToggles[feature]
        Toggle.Text = feature .. ": " .. (espToggles[feature] and "ON" or "OFF")
        Toggle.TextColor3 = espToggles[feature] and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    end)
    yOffset = yOffset + 40
end

-- Exploits Tab (Updated with Document's Loop TP)
local flyEnabled = false
local flySpeed = 75
local controlSpeed = 10000
local noClipEnabled = false
local infiniteJumpEnabled = false
local teleporting = false
local tpBehindOffset = 5
local tpBehindHeight = 0

local FlyToggle = Instance.new("TextButton")
FlyToggle.Size = UDim2.new(0, 100, 0, 30)
FlyToggle.Position = UDim2.new(0, 10, 0, 10)
FlyToggle.Text = "Fly: OFF"
FlyToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
FlyToggle.BackgroundTransparency = 1
FlyToggle.TextTransparency = 1
FlyToggle.TextColor3 = Color3.fromRGB(255, 0, 0)
FlyToggle.Font = Enum.Font.SourceSans
FlyToggle.TextSize = 16
FlyToggle.Parent = tabContents["Exploits"]

local FlySpeedLabel = Instance.new("TextLabel")
FlySpeedLabel.Size = UDim2.new(0, 100, 0, 20)
FlySpeedLabel.Position = UDim2.new(0, 10, 0, 50)
FlySpeedLabel.Text = "Fly Speed: " .. flySpeed
FlySpeedLabel.BackgroundTransparency = 1
FlySpeedLabel.TextTransparency = 1
FlySpeedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
FlySpeedLabel.Font = Enum.Font.SourceSans
FlySpeedLabel.TextSize = 16
FlySpeedLabel.Parent = tabContents["Exploits"]

local FlySpeedSlider = Instance.new("TextButton")
FlySpeedSlider.Size = UDim2.new(0, 200, 0, 20)
FlySpeedSlider.Position = UDim2.new(0, 10, 0, 70)
FlySpeedSlider.Text = ""
FlySpeedSlider.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
FlySpeedSlider.BackgroundTransparency = 1
FlySpeedSlider.Parent = tabContents["Exploits"]

local FlySpeedKnob = Instance.new("Frame")
FlySpeedKnob.Size = UDim2.new(0, 10, 1, 0)
FlySpeedKnob.Position = UDim2.new((flySpeed - 10) / 190, 0, 0, 0)
FlySpeedKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 252)
FlySpeedKnob.BackgroundTransparency = 1
FlySpeedKnob.Parent = FlySpeedSlider

local draggingSlider = false
FlySpeedSlider.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingSlider = true
    end
end)

FlySpeedSlider.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        draggingSlider = false
    end
end)

RunService.RenderStepped:Connect(function()
    if draggingSlider then
        local mouseX = UserInputService:GetMouseLocation().X
        local sliderPos = FlySpeedSlider.AbsolutePosition.X
        local sliderWidth = FlySpeedSlider.AbsoluteSize.X
        local newPos = math.clamp((mouseX - sliderPos) / sliderWidth, 0, 1)
        FlySpeedKnob.Position = UDim2.new(newPos, 0, 0, 0)
        flySpeed = math.floor(10 + (newPos * 190))
        FlySpeedLabel.Text = "Fly Speed: " .. flySpeed
    end
end)

local function toggleFly()
    flyEnabled = not flyEnabled
    FlyToggle.Text = "Fly: " .. (flyEnabled and "ON" or "OFF")
    FlyToggle.TextColor3 = flyEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    
    local character = getCharacter()
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local humanoid = character:WaitForChild("Humanoid")
    
    if flyEnabled then
        humanoid:ChangeState(Enum.HumanoidStateType.Physics)
        local bv = Instance.new("BodyVelocity")
        bv.Velocity = Vector3.new(0, 0, 0)
        bv.MaxForce = Vector3.new(controlSpeed, controlSpeed, controlSpeed)
        bv.Parent = rootPart
        
        local bg = Instance.new("BodyGyro")
        bg.MaxTorque = Vector3.new(controlSpeed, controlSpeed, controlSpeed)
        bg.P = 5000
        bg.D = 500
        bg.CFrame = rootPart.CFrame
        bg.Parent = rootPart
        
        spawn(function()
            while flyEnabled do
                local char = getCharacter()
                local root = char:WaitForChild("HumanoidRootPart")
                local cam = workspace.CurrentCamera
                local move = Vector3.new(0, 0, 0)
                
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + Vector3.new(0, 0, -1) end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move + Vector3.new(0, 0, 1) end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move + Vector3.new(-1, 0, 0) end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + Vector3.new(1, 0, 0) end
                if UserInputService:IsKeyDown(Enum.KeyCode.Space) then move = move + Vector3.new(0, 1, 0) end
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift) then 
                    move = move + Vector3.new(0, -1, 0) 
                end
                
                if move.Magnitude > 0 then
                    move = move.Unit * flySpeed
                    bv.Velocity = cam.CFrame:VectorToWorldSpace(move)
                    bg.CFrame = cam.CFrame
                else
                    bv.Velocity = Vector3.new(0, 0, 0)
                end
                wait()
            end
            if rootPart:FindFirstChild("BodyVelocity") then rootPart.BodyVelocity:Destroy() end
            if rootPart:FindFirstChild("BodyGyro") then rootPart.BodyGyro:Destroy() end
            humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
        end)
    end
end

FlyToggle.MouseButton1Click:Connect(toggleFly)

local NoClipToggle = Instance.new("TextButton")
NoClipToggle.Size = UDim2.new(0, 100, 0, 30)
NoClipToggle.Position = UDim2.new(0, 10, 0, 100)
NoClipToggle.Text = "NoClip: OFF"
NoClipToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
NoClipToggle.BackgroundTransparency = 1
NoClipToggle.TextTransparency = 1
NoClipToggle.TextColor3 = Color3.fromRGB(255, 0, 0)
NoClipToggle.Font = Enum.Font.SourceSans
NoClipToggle.TextSize = 16
NoClipToggle.Parent = tabContents["Exploits"]

local Noclip = nil
local Clip = true

function noclip()
    Clip = false
    local function Nocl()
        if Clip == false and PlayersService.LocalPlayer.Character ~= nil then
            for _, v in pairs(PlayersService.LocalPlayer.Character:GetDescendants()) do
                if v:IsA("BasePart") and v.CanCollide and v.Name ~= floatName then
                    v.CanCollide = false
                end
            end
        end
        wait(0.21)
    end
    Noclip = game:GetService("RunService").Stepped:Connect(Nocl)
end

function clip()
    if Noclip then Noclip:Disconnect() end
    Clip = true
end

NoClipToggle.MouseButton1Click:Connect(function()
    noClipEnabled = not noClipEnabled
    NoClipToggle.Text = "NoClip: " .. (noClipEnabled and "ON" or "OFF")
    NoClipToggle.TextColor3 = noClipEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    if noClipEnabled then
        noclip()
    else
        clip()
    end
end)

local InfiniteJumpToggle = Instance.new("TextButton")
InfiniteJumpToggle.Size = UDim2.new(0, 100, 0, 30)
InfiniteJumpToggle.Position = UDim2.new(0, 10, 0, 140)
InfiniteJumpToggle.Text = "Inf Jump: OFF"
InfiniteJumpToggle.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
InfiniteJumpToggle.BackgroundTransparency = 1
InfiniteJumpToggle.TextTransparency = 1
InfiniteJumpToggle.TextColor3 = Color3.fromRGB(255, 0, 0)
InfiniteJumpToggle.Font = Enum.Font.SourceSans
InfiniteJumpToggle.TextSize = 16
InfiniteJumpToggle.Parent = tabContents["Exploits"]

UserInputService.JumpRequest:Connect(function()
    if infiniteJumpEnabled then
        local character = getCharacter()
        local humanoid = character:WaitForChild("Humanoid")
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

InfiniteJumpToggle.MouseButton1Click:Connect(function()
    infiniteJumpEnabled = not infiniteJumpEnabled
    InfiniteJumpToggle.Text = "Inf Jump: " .. (infiniteJumpEnabled and "ON" or "OFF")
    InfiniteJumpToggle.TextColor3 = infiniteJumpEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
end)

local TeleportTargetInput = Instance.new("TextBox")
TeleportTargetInput.Size = UDim2.new(0, 200, 0, 30)
TeleportTargetInput.Position = UDim2.new(0, 10, 0, 180)
TeleportTargetInput.Text = "Enter Player Name"
TeleportTargetInput.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
TeleportTargetInput.BackgroundTransparency = 1
TeleportTargetInput.TextTransparency = 1
TeleportTargetInput.TextColor3 = Color3.fromRGB(255, 255, 255)
TeleportTargetInput.Font = Enum.Font.SourceSans
TeleportTargetInput.TextSize = 16
TeleportTargetInput.Parent = tabContents["Exploits"]

local selectedPlayer = nil
TeleportTargetInput.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local inputValue = TeleportTargetInput.Text:lower()
        local matchingPlayer = nil
        for _, player in ipairs(PlayersService:GetPlayers()) do
            local playerName = player.Name:lower()
            local playerDisplayName = player.DisplayName:lower()
            if playerName:find(inputValue, 1, true) or playerDisplayName:find(inputValue, 1, true) then
                matchingPlayer = player
                break
            end
        end
        selectedPlayer = matchingPlayer
        TeleportTargetInput.Text = matchingPlayer and matchingPlayer.Name or "Enter Player Name"
    end
end)

local StartLoopTPButton = Instance.new("TextButton")
StartLoopTPButton.Size = UDim2.new(0, 100, 0, 30)
StartLoopTPButton.Position = UDim2.new(0, 220, 0, 180)
StartLoopTPButton.Text = "Start Loop TP"
StartLoopTPButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
StartLoopTPButton.BackgroundTransparency = 1
StartLoopTPButton.TextTransparency = 1
StartLoopTPButton.TextColor3 = Color3.fromRGB(255, 255, 255)
StartLoopTPButton.Font = Enum.Font.SourceSans
StartLoopTPButton.TextSize = 16
StartLoopTPButton.Parent = tabContents["Exploits"]

local StopLoopTPButton = Instance.new("TextButton")
StopLoopTPButton.Size = UDim2.new(0, 100, 0, 30)
StopLoopTPButton.Position = UDim2.new(0, 220, 0, 220)
StopLoopTPButton.Text = "Stop Loop TP"
StopLoopTPButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
StopLoopTPButton.BackgroundTransparency = 1
StopLoopTPButton.TextTransparency = 1
StopLoopTPButton.TextColor3 = Color3.fromRGB(255, 255, 255)
StopLoopTPButton.Font = Enum.Font.SourceSans
StopLoopTPButton.TextSize = 16
StopLoopTPButton.Parent = tabContents["Exploits"]

local function loopBehind(targetPlayer)
    teleporting = true
    local player = PlayersService.LocalPlayer
    while teleporting do
        local targetCharacter = targetPlayer.Character
        local targetHumanoidRootPart = targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart")
        local playerCharacter = player.Character
        local playerHumanoidRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")
        if playerHumanoidRootPart and targetHumanoidRootPart then
            local targetCframe = targetHumanoidRootPart.CFrame
            local targetLookVector = targetCframe.LookVector
            local targetPosition = targetCframe.Position
            local newPosition = targetPosition - (targetLookVector * tpBehindOffset) + Vector3.new(0, tpBehindHeight, 0)
            playerHumanoidRootPart.CFrame = CFrame.new(newPosition, newPosition + targetLookVector)
        end
        task.wait()
    end
end

StartLoopTPButton.MouseButton1Click:Connect(function()
    if selectedPlayer then
        loopBehind(selectedPlayer)
    end
end)

StopLoopTPButton.MouseButton1Click:Connect(function()
    teleporting = false
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    if flyEnabled then
        wait(0.1)
        toggleFly()
        toggleFly()
    end
    if teleporting then
        wait(0.1)
        loopBehind(selectedPlayer)
        loopBehind(selectedPlayer) -- Toggle off and on to restart
    end
end)

-- GUI Animation Setup (unchanged)
local isGuiVisible = false
local fadeInInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
local fadeOutInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
local scaleInInfo = TweenInfo.new(0.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)
local scaleOutInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

local function animateGui(isVisible)
    if isVisible == isGuiVisible then return end
    isGuiVisible = isVisible

    if isVisible then
        MainFrame.Visible = true
        local fadeIn = TweenService:Create(MainFrame, fadeInInfo, {BackgroundTransparency = 0})
        local fadeInTab = TweenService:Create(TabFrame, fadeInInfo, {BackgroundTransparency = 0})
        local fadeInContent = TweenService:Create(ContentFrame, fadeInInfo, {BackgroundTransparency = 0})
        MainFrame.Size = UDim2.new(0, 400, 0, 0)
        local scaleIn = TweenService:Create(MainFrame, scaleInInfo, {Size = UDim2.new(0, 400, 0, 300)})

        fadeIn:Play()
        fadeInTab:Play()
        fadeInContent:Play()
        scaleIn:Play()

        for _, button in pairs(TabFrame:GetChildren()) do
            if button:IsA("TextButton") then
                button.TextTransparency = 1
                local fadeInText = TweenService:Create(button, fadeInInfo, {TextTransparency = 0})
                fadeInText:Play()
            end
        end

        if tabContents then
            for _, tabContent in pairs(tabContents) do
                for _, child in pairs(tabContent:GetChildren()) do
                    if child:IsA("TextButton") or child:IsA("TextLabel") then
                        child.TextTransparency = 1
                        local fadeInChild = TweenService:Create(child, fadeInInfo, {TextTransparency = 0})
                        fadeInChild:Play()
                    end
                    if child:IsA("TextButton") then
                        child.BackgroundTransparency = 1
                        local fadeInBg = TweenService:Create(child, fadeInInfo, {BackgroundTransparency = 0})
                        fadeInBg:Play()
                    end
                end
            end
        end
    else
        local fadeOut = TweenService:Create(MainFrame, fadeOutInfo, {BackgroundTransparency = 1})
        local fadeOutTab = TweenService:Create(TabFrame, fadeOutInfo, {BackgroundTransparency = 1})
        local fadeOutContent = TweenService:Create(ContentFrame, fadeOutInfo, {BackgroundTransparency = 1})
        local scaleOut = TweenService:Create(MainFrame, scaleOutInfo, {Size = UDim2.new(0, 400, 0, 0)})

        fadeOut:Play()
        fadeOutTab:Play()
        fadeOutContent:Play()
        scaleOut:Play()

        for _, button in pairs(TabFrame:GetChildren()) do
            if button:IsA("TextButton") then
                local fadeOutText = TweenService:Create(button, fadeOutInfo, {TextTransparency = 1})
                fadeOutText:Play()
            end
        end

        if tabContents then
            for _, tabContent in pairs(tabContents) do
                for _, child in pairs(tabContent:GetChildren()) do
                    if child:IsA("TextButton") or child:IsA("TextLabel") then
                        local fadeOutChild = TweenService:Create(child, fadeOutInfo, {TextTransparency = 1})
                        fadeOutChild:Play()
                    end
                    if child:IsA("TextButton") then
                        local fadeOutBg = TweenService:Create(child, fadeOutInfo, {BackgroundTransparency = 1})
                        fadeOutBg:Play()
                    end
                end
            end
        end

        scaleOut.Completed:Connect(function()
            MainFrame.Visible = false
        end)
    end
end

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.Q then
        animateGui(not isGuiVisible)
    end
end)

local dragging, dragInput, dragStart, startPos
MainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

MainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

RunService.Stepped:Connect(function()
    if dragging and dragInput then
        local delta = dragInput.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

tabContents["Aimbot"].Visible = true
TabFrame:GetChildren()[1].BackgroundColor3 = Color3.fromRGB(70, 70, 70)
currentTab = "Aimbot"

spawn(function()
    wait(0.1)
    animateGui(true)
end)
